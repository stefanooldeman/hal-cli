#!/usr/bin/env ruby

require './app'

def print_links(link_index)
  link_index.each do |id, link|
    puts "- [#{id}] #{link.name}: #{link.default_method.upcase} #{link.base_href}"
  end
end

# Navigate to a link
start = State.new :start do |api, state|
  puts "Welcome, this is your navigation"
  state.api = api.get
  link_index = Util.index_links(state.api) 
  print_links(link_index)
  state.data.link_index = link_index
  puts "Pick a section to start with (from 1 to #{link_index.size})"
end
start.eval do |api, state, _|
  link = state.data.link_index[state.response.to_i]
  raise FSM::InvalidResponse.new if link.nil?

  state.data.link = link
  "> Working with '#{link.name}'"
end


# ### Create a task ###
# create_task = State.new :create_task do |api, data|
#   puts "> Type a new task in plain text, submit with an enter?"
# end
# create_task.eval do |api, _state, _|
#   api.post(title: state.response)
# end

# ### List tasks ###
# list_tasks = State.new :list_tasks do |api, state| 
#   # ask what you want to do with the list of tasks?
# end
# list_tasks.eval do |api, state, queue|
# end

# Actions on a chosen link
options = State.new :options do |api, state|
  current_link = state.data.link # available
  binding.pry

  result = api.options
  allowed = result.header['allow'].scan(/\w+/)

  puts "Available options on #{current_link.name}"
  methods_index = {}
  allowed.map.with_index.each do |x,i|
    if x != 'OPTIONS' && x != 'HEAD'
      puts "- [#{i}] #{x}"
      methods_index[i] = x
    end
  end
  state.data.methods_index
end
options.eval do |api, state, queue|
  method = state.data.methods_index[state.response]
  raise FSM::InvalidResponse if method.nil?

  # store: state.data.method = method

  case method
  when "GET"
    queue << list_tasks
  when "POST"
    # push new state to next to create a task
  end

  "You picked #{method}"
end


api = Client.new
fsm = FSM.new(api)
fsm.add(start)
fsm.add(options)
fsm.begin
